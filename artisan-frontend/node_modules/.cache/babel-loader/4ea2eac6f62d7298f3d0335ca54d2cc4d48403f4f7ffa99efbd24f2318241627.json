{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\n// First, define an async thunk\nexport const clearError = createAsyncThunk(\"error/clean\",\n// A unique action type\nasync () => {\n  const response = await new Promise(resolve => setTimeout(() => resolve({\n    message: \"\",\n    level: \"error\"\n  }), 3000));\n  return response;\n});\nconst initialState = {\n  message: \"\",\n  level: \"error\"\n};\nconst chatSlice = createSlice({\n  name: \"chat\",\n  initialState,\n  reducers: {\n    addError: (state, {\n      payload\n    }) => {\n      state.message = payload.message;\n      state.level = payload.level;\n    }\n    // A bit of async thunk above example with setTimeout\n    // clearError: (state, { payload }) => {\n    // \tstate.message = \"\";\n    // },\n  },\n  extraReducers: builder => {\n    builder.addCase(clearError.fulfilled, (state, {\n      payload\n    }) => {\n      state.message = payload.message;\n      state.level = payload.level;\n    });\n  }\n});\nexport const {\n  addError\n} = chatSlice.actions;\nexport default chatSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","clearError","response","Promise","resolve","setTimeout","message","level","initialState","chatSlice","name","reducers","addError","state","payload","extraReducers","builder","addCase","fulfilled","actions","reducer"],"sources":["/home/lightberry/bucket/artisan-test/frontend/src/redux/errorsReducer.ts"],"sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\n\ninterface InitialStateType {\n\tmessage: string;\n\tlevel: \"error\" | \"warning\" | \"info\";\n}\n\n// First, define an async thunk\nexport const clearError = createAsyncThunk(\n\t\"error/clean\", // A unique action type\n\tasync () => {\n\t\tconst response: InitialStateType = await new Promise((resolve) =>\n\t\t\tsetTimeout(() => resolve({ message: \"\", level: \"error\" }), 3000)\n\t\t);\n\t\treturn response;\n\t}\n);\n\nconst initialState: InitialStateType = {\n\tmessage: \"\",\n\tlevel: \"error\",\n};\n\nconst chatSlice = createSlice({\n\tname: \"chat\",\n\tinitialState,\n\treducers: {\n\t\taddError: (state, { payload }) => {\n\t\t\tstate.message = payload.message;\n\t\t\tstate.level = payload.level;\n\t\t},\n\t\t// A bit of async thunk above example with setTimeout\n\t\t// clearError: (state, { payload }) => {\n\t\t// \tstate.message = \"\";\n\t\t// },\n\t},\n\textraReducers: (builder) => {\n\t\tbuilder.addCase(clearError.fulfilled, (state, { payload }) => {\n\t\t\tstate.message = payload.message;\n\t\t\tstate.level = payload.level;\n\t\t});\n\t},\n});\n\nexport const { addError } = chatSlice.actions;\nexport default chatSlice.reducer;\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,kBAAkB;AAC9C,SAASC,gBAAgB,QAAQ,kBAAkB;AAOnD;AACA,OAAO,MAAMC,UAAU,GAAGD,gBAAgB,CACzC,aAAa;AAAE;AACf,YAAY;EACX,MAAME,QAA0B,GAAG,MAAM,IAAIC,OAAO,CAAEC,OAAO,IAC5DC,UAAU,CAAC,MAAMD,OAAO,CAAC;IAAEE,OAAO,EAAE,EAAE;IAAEC,KAAK,EAAE;EAAQ,CAAC,CAAC,EAAE,IAAI,CAChE,CAAC;EACD,OAAOL,QAAQ;AAChB,CACD,CAAC;AAED,MAAMM,YAA8B,GAAG;EACtCF,OAAO,EAAE,EAAE;EACXC,KAAK,EAAE;AACR,CAAC;AAED,MAAME,SAAS,GAAGV,WAAW,CAAC;EAC7BW,IAAI,EAAE,MAAM;EACZF,YAAY;EACZG,QAAQ,EAAE;IACTC,QAAQ,EAAEA,CAACC,KAAK,EAAE;MAAEC;IAAQ,CAAC,KAAK;MACjCD,KAAK,CAACP,OAAO,GAAGQ,OAAO,CAACR,OAAO;MAC/BO,KAAK,CAACN,KAAK,GAAGO,OAAO,CAACP,KAAK;IAC5B;IACA;IACA;IACA;IACA;EACD,CAAC;EACDQ,aAAa,EAAGC,OAAO,IAAK;IAC3BA,OAAO,CAACC,OAAO,CAAChB,UAAU,CAACiB,SAAS,EAAE,CAACL,KAAK,EAAE;MAAEC;IAAQ,CAAC,KAAK;MAC7DD,KAAK,CAACP,OAAO,GAAGQ,OAAO,CAACR,OAAO;MAC/BO,KAAK,CAACN,KAAK,GAAGO,OAAO,CAACP,KAAK;IAC5B,CAAC,CAAC;EACH;AACD,CAAC,CAAC;AAEF,OAAO,MAAM;EAAEK;AAAS,CAAC,GAAGH,SAAS,CAACU,OAAO;AAC7C,eAAeV,SAAS,CAACW,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}